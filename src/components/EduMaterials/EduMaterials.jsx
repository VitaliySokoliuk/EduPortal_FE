import './EduMaterials.scss';
import './../../utils/normilize.scss';

export const EduMaterials = () => {
    return (
        <div className="taras_superhero_and_likes_cucumbers">
            <p>Пропонуємо ознайомитися з основними принципами об&#39;єктно-орієнтованого програмування &ndash; однієї з найбільш важливих методологій розробки, яка ґрунтується на уявленні про програму як про сукупність об&#39;єктів, кожен з яких є екземпляром певного класу, а класи утворюють ієрархію наслідування.</p>
            <h3>
                <strong>ІНКАПСУЛЯЦІЯ</strong>
            </h3>
            <p>Одним з визначальних факторів при проектуванні компонентів програми є приховування внутрішніх даних компоненту і деталей його реалізації від інших компонентів програми та надання набору методів для взаємодії з ним (API). Цей принцип є одним з чотирьох фундаментальних принципів ООП і називається інкапсуляцією.</p>
            <h3>
                <strong>Правильна інкапсуляція має велике значення з багатьох причин: </strong>
            </h3>
            <p>1. Вона сприяє повторному використанню компонентів: оскільки в цьому випадку компоненти взаємодіють між собою лише через їх API і нечутливі до змін внутрішньої структури, вони можуть використовуватись в більш широкому контексті.</p> <p>2. Інкапсуляція пришвидшує процес розробки: слабко пов&#39;язані один з одним компоненти (тобто компоненти, чий код якомога менше звертається або використовує код інших компонентів) можуть розроблятися, тестуватися та доповнюватися незалежно.</p>
            <p>3. Правильно інкапсульовані компоненти більш зрозумілі та легше налагоджуються, що спрощує підтримку програми.</p>
            <p>У мові Java інкапсуляція реалізована за допомогою системи класів, які дозволяють зібрати інформацію про об&#39;єкт в одному місці; пакетів, які групують класи по певному критерію, і модифікаторів доступу, якими можна позначити весь клас або його поле чи метод.</p>
            <h3>
                <strong>Всього існує чотири модифікатори доступу: </strong>
            </h3>
            <ul>
                <li>
                    <strong>public</strong> &ndash; повний доступ до сутності (полю або методу класу) з будь-якого пакету;
                </li>
                <li>
                    <strong>protected</strong> &ndash; доступ до сутності лише для класів свого пакету і нащадків класу;
                </li>
                <li>
                    <strong>private</strong> &ndash; доступ тільки всередині класу, в якому оголошена сутність;
                </li>
                <li>
                    <strong>неявний модифікатор за замовчуванням</strong> (за відсутності трьох явних) &ndash; доступ до сутності лише для класів свого пакету.
                </li>
            </ul>
            <p>Для досягнення правильної інкапсуляції також необхідно надати коректний API для роботи з компонентом. Наприклад, в сеттер для змінної можна включити логіку перевірки значень, які передаються, або не надавати сеттери в класі взагалі, якщо клас повинен бути доступним лише для читання.</p>
            <p>Приклад коректної інкапсуляції класу:</p>
            <p>
                <img src="https://lh5.googleusercontent.com/_KZZZmEa3AHdg4m0ufip2kIVGx_kZ-8NbfKU1RoikY2cmcffQHAhiIU6fcwOROwSubu9NPjJ4NkVHv4pErUaYdOjpFsYQF6_HPdW42qwkKItKqQSm6ZE1e9y_7eEuxjYmvkvuTOz" />
            </p>
            <p>У наведеному вище прикладі значення змінної name задається при створенні об&#39;єкта і не може бути змінене ззвоні, так як сеттер для змінної відсутній. В сеттері для змінної age реалізована перевірка на коректність параметру, який передається і викид виключення при невірному значенні.
            </p>
            <h3>
                <strong>НАСЛІДУВАННЯ </strong>
            </h3>
            <p>Наслідування є одним з найвагоміших принципів об&#39;єктно-орієнтованого програмування, оскільки воно дозволяє створювати ієрархічні структури об&#39;єктів. Використовуючи наслідування можна створити загальний клас, який буде визначати характеристики і поведінку, властиві певному набору пов&#39;язаних об&#39;єктів. В подальшому цей клас може наслідуватися іншими, другорядними класами, кожен з яких додаватиме унікальні, властиві лише йому характеристики і доповнюватиме або змінюватиме поведінку базового класу. В термінах Java такий загальний клас називається суперкласом (superclass) або базовим класом (base class), або батьківським класом (parent class), а клас, який його наслідує - підкласом (subclass) або дочірнім класом (child class), або похідним класом. (derived class).</p> <p>Наслідування реалізує відношення &laquo;є&raquo; (&ldquo;is-a&rdquo;) між суперкласом і підлкасом. Нехай, наприклад, класи Employee та Manager являють собою абстракцію понять &laquo;Співробітник&raquo; і &laquo;Менеджер&raquo;. Кожний менеджер є також співробітником компанії, в якій він працює, отже клас Manager знаходиться у відношенні &ldquo;is-a&rdquo; з класом Employee. Таким чином, з точки зору наслідування, при побудові ієрархії класів, клас Employee буде суперкласом, а клас Manager &ndash; дочірнім класом. При цьому клас, який є нащадком якого-небудь класу, може бути суперкласом для одного чи декількох інших класів. Також на відміну від, наприклад, C++, в Java відсутнє множинне наслідування , тобто будь-який клас може мати не більше одного батьківського класу. А всі класи, суперклас котрих явно не вказаний, наслідують клас Object.</p>
            <p>Клас Employee у вищезгаданому прикладі, є суперкласом не тому, що він головніший за клас Manager або містить більше функціональності. Насправді, вірно зворотне твердження: функціональність підкласів не вужча, а часто суттєво ширша за функціональність їх батьківських класів. Префікси &laquo;супер-&raquo; і &laquo;під-&raquo; прийшли в Java з математики: множина всіх менеджерів міститься в множині всіх співробітників, і, таким чином, є підмножиною множини співробітників.
            </p>
            <p>Для того, щоб наслідувати якийсь клас в Java, використовується ключове слово extends:
            </p>
            <p>
                <img src="https://lh3.googleusercontent.com/8NoBcgfUf6mebobK2h88v0pHx1zX9hKIyfLTOyKviuG3q_pq4nSa_EiJ4eYaqPiCbkKOxO4STdKdZyn24eFpFScq7j_Q2_OIg_-j4xkQdPvzn5mnPiIcUTY3aXLIoK5R3dXzwbII" />
            </p>
            <p>У прикладі вище клас Employee є базовим класом для класа Manager, а клас Manager &ndash; підкласом класа Employee. Клас Employee абстрагує базові характеристики для всіх співробітників компанії &ndash; ім&rsquo;я, прізвище, розмір заробітної плати і дату прийому на роботу, а клас Manager доповнює ці характеристики відсотком премії для менеджерів і змінює поведінку методу getSalary() базового класу, використовуючи поліморфізм.
            </p>
            <h3>
                <strong>ПОЛІМОРФІЗМ</strong>
            </h3>
            <p>Розглядаючи поліморфізм необхідно пам&#39;ятати, що цей принцип нерозривно пов&#39;язаний з іншим принципом ООП &ndash; наслідуванням, яке допомагає реалізувати поліморфізм. Візьмемо для прикладу абстрактний клас &laquo;Автомобіль&raquo;, який наслідують два конкретних класи &ndash; &laquo;Спортивний автомобіль&raquo; та &laquo;Вантажний автомобіль&raquo;.
            </p>
            <p>І спортивні, і вантажні автомобілі володітимуть спільними характеристиками і матимуть можливість виконувати загальні для всіх автомобілів дії, вказані в абстрактному батьківському класі, але конкретна реалізація цих дій може бути різною.</p> <p>Наприклад, загальна для всіх автомобілів дія &laquo;завестись&raquo; у спортивному автомобілі може бути реалізована шляхом натискання кнопки, а у вантажного - за допомогою ключа. Один результат &ndash; різні рішення. В цьому і полягає поліморфізм.
            </p>
            <p>Точніше,
                <strong>поліморфізм -</strong> один з принципів ООП, який дозволяє викликом перевизначеного методу через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному класу, на який посилається ця змінна.
                <img src="https://lh3.googleusercontent.com/potaFusClXjaQBgEL6ZWo_KG3mSR_uxVKK-vxq-AW3Xly9iI400HyP7N4OlNKwUQUj81SAgtyrNW_vFzSTrQ750ZlG_VOdV8NlzzSt3tnRwXI_0lPQ7AMyGcMaaplYRdi1mWtYhe" />
            </p>
            <p>Код наведений вище дає приклад поліморфізму. Спочатку змінній батьківського класу Vehicle присвоюється об&#39;єкт дочірнього класу SportCar. Під час виклику методу start() на консоль буде виведено: &quot;Starting my fancy sport car!&quot;
            </p>
            <p>При подальшому присвоєнні цієї ж змінної об&#39;єкту дочірнього класу Truck і виклику того ж методу start() на консоль виводитиметься: &quot;Starting my heavy truck!&quot;
            </p>
            <h3>
                <strong>АБСТРАКЦІЯ</strong>
            </h3>
            <p>Відносно недавно абстракцію почали виділяти, як самостійний четвертий принцип.
            </p>
            <p>Одне з визначень слова &laquo;абстракція&raquo;, які можна зустріти в сучасних словниках:
            </p>
            <p>
                <strong>Абстракція</strong> (від лат. abstractio &mdash; виокремлення, відсторонення або відділення) &mdash; теоретичний прийом дослідження, який дозволяє відсторонитися від деяких несуттєвих, у певному сенсі, властивостей досліджуваних явищ і виокремити суттєві та визначальні властивості.
            </p>
            <p>Всі мови програмування пропонують їх користувачу деякі абстрації. Так мови групи асемблер є свого роду абстракцією відповідних мікропроцесорів, оскільки дозволяють відволіктися від деталей їх реалізації та звертатися до них через набір більш високорівневих інструкцій. Імперативні мови програмування, які з&#39;явилися після асемблеру, наприклад Basic, Fortran, C, є більш високим рівнем абстракції над асемблерними мовами &ndash; вони дають можливість використовувати більш звичні для людини синтаксичні конструкції за рахунок наближення синтаксису до природніх мов. Об&#39;єктно-орієнтовані мови, такі як Java, виводят розробку на ще вищий рівень абстракції: об&#39;єкти в ООП являють собою моделі понять оточуючого світу, такі як Працівник, Сервер, Запис в щоденнику, і виділяють лише властивості цих понять, необхідні в конкретному випадку для вирішення конкретної проблеми. Наприклад, клас Student в програмі обліку студентів університету, крім загальних полів, таких як ім&#39;я, прізвище, дата народження і т.д., міститиме поля, які відображають інформацію про номер залікової книжки, статус студента (дійсний, академічна відпустка, відраховано), факультет, номер його групи, оцінки за семестр і т. ін. Але для такого ж класа Student в програмі обліку студентів у тренінг-центрі ЕРАМ така інформація буде неактуальна: клас міститиме поля, які відображають навчальний проект, на який був розподілений студент, рівень його англійської мови за результатами останнього тестування, кількість відвіданих заходів та ін.
            </p>
            <p>В цьому і полягає абстракція
                <strong>:</strong> фокусування розробника на конкретних властивостях об&#39;єкта залежить від тих задач, які повинен вирішувати об&#39;єкт. Наслідком такого підходу є те, що, якщо в імперативних мовах програмісту необхідно думати в термінах комп&#39;ютерної логіки, то в об&#39;єктно-орієнтованих мовах розробник думає в термінах проблемної сфери, в якій він розробляє програму.
            </p>
        </div>
    )
}